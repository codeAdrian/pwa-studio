/**
 * Autogenerate an image tag with `sizes` and `srcSet` attributes, using simple
 * media conditions, a source URL, and an array of pixel widths for resized
 * images to create. Renders the image resize URLs expected by venia-upward.
 *
 * Optionally, takes a render callback so you can use other DOM structures
 * besides literal img tags to display responsive images. The img tag is
 * required, however.
 */

import React, { Component } from 'react';
import { arrayOf, func, number, oneOf, string } from 'prop-types';
import makeMediaUrl from 'src/util/makeMediaUrl';

class ResponsiveImage extends Component {
    static propTypes = {
        alt: string.isRequired,
        className: string,
        render: func,
        sizes: string.isRequired,
        src: string.isRequired,
        type: oneOf(['product', 'category', 'other']).isRequired,
        widthOptions: arrayOf(number).isRequired
    };

    /**
     * ## Updating the Background Image
     *
     * TODO: Image elements use srcsets to change their source file according to
     * media conditions, but the equivalent CSS function `image-set` is not well
     * supported yet.
     *
     * Users of ResponsiveImage may pass a render prop to render custom DOM
     * using the responsive image element and its current source value.
     *
     * This render function probably needs the image URLs generated by
     * ResponsiveImage (otherwise there would be no point in a render prop), so
     * we have to keep track of them as they change.
     *
     * First we maintain a per-instance array of DOM elements awaiting update.
     */

    toSetStyle = [];

    /**
     * We will pass a reference to this `setToUrl` method to the render
     * function. It takes one argument: either a string for a style attribute to
     * set, or a function to run arbitrary code on the ref.
     */

    setToUrl = propToSet => {
        const typeOfArg = typeof propToSet;
        const ref = React.createRef();
        /**
         * Updating the `style` property with a CSS variable does not trigger a
         * repaint, so we have to modify the string in the style attribute.
         */
        let callback;
        if (typeOfArg === 'function') {
            callback = propToSet;
        } else if (typeOfArg === 'string') {
            const styleRegexp = new RegExp(`${propToSet}:\\s*[^;]+(;?)`);
            callback = (element, currentSrc) => {
                const declaration = `${propToSet}: url("${currentSrc}")`;
                let style = element.getAttribute('style');
                if (style) {
                    // Backreference $1 is the possible semicolon from the
                    // matched declaration. Let's not insert extras or remove
                    // necessary ones.
                    style = style.replace(styleRegexp, `${declaration}$1`);
                } else {
                    style = declaration;
                }
                element.setAttribute('style', style);
            };
        } else {
            throw new Error(
                'Argument to `setToUrl` callback must be a function (element, currentSrc) or a string for a style property to set.'
            );
        }
        this.toSetStyle.push({ ref, callback });

        /**
         * The function returns the new ref, which the consumer MUST assign to
         * the `ref` prop of the element which needs updating.
         */
        return ref;
    };

    /**
     * Whenever the underlying Image element changes sources according to media
     * conditions, it fires a `load` event when the new source has loaded and
     * `handleLoad()` runs. `handleLoad()` uses this property to run a callback
     * on all of the refs registered in the last render, to update DOM elements
     * with the current source of the image.
     *
     */

    handleLoad = e => {
        this.toSetStyle.forEach(({ ref, callback }) =>
            callback(ref.current, e.target.currentSrc)
        );
    };

    render() {
        // Before each render cycle, clear old refs; otherwise, the instance
        // will leak memory.
        this.toSetStyle = [];
        const {
            alt,
            className,
            render,
            sizes,
            src,
            type,
            widthOptions,
            ...rest
        } = this.props;

        // If the browser doesn't support srcset, we assume it's on an older
        // device and needs smaller assets.
        const fallbackWidth = Math.min(...widthOptions);
        // If the sizes prop contains media conditions, add a fallback to the
        // minimum size if no conditions pass.
        const finalSizes =
            sizes.indexOf('(') !== -1 ? `${sizes}, ${fallbackWidth}px` : sizes;

        const image = (
            <img
                alt={alt}
                onLoad={this.handleLoad}
                className={className}
                sizes={finalSizes}
                src={makeMediaUrl(src, { type, width: fallbackWidth })}
                srcSet={widthOptions
                    .map(
                        width =>
                            `${makeMediaUrl(src, { width, type })} ${width}w`
                    )
                    .join(', ')}
                {...rest}
            />
        );

        // Try to help developers with a common mistake.
        if (render) {
            let imageUsed;
            const renderImage = () => {
                imageUsed = true;
                return image;
            };
            const tree = render(renderImage, this.setToUrl);
            if (!imageUsed) {
                throw new Error(
                    'ResponsiveImage: The rendered image was not used in the passed `render` function. The render function must return a Virtual DOM tree that includes the passed `image`, or it will not start responding automatically to media conditions.'
                );
            }
            return tree;
        }

        // If no render prop, just return the image!
        return image;
    }
}

export default ResponsiveImage;
